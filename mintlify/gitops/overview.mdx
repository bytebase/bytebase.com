---
title: Overview
---

## Goal

GitOps for database CI/CD brings the same rigor and automation used in application development to database schema management. Database schema changes are equivalent to API changes in microservices - they define contracts between services, and misalignment can break production systems.

By treating databases as dependencies that require versioning, compatibility management, and progressive rollout strategies, schema changes gain the same safety and predictability as application code.

## Why Database Schema Changes Matter

Database schema changes are fundamentally similar to API changes:
- They define contracts between services
- Breaking changes can cause application failures
- They require versioning and compatibility considerations
- They benefit from progressive rollout and feature flagging

Bytebase enables database-as-code workflows, allowing you to manage database changes through your version control system (VCS) with the same process and confidence as application code.

## Core Capabilities

### Database-as-Code Workflow

- **Unified CI/CD Pipeline** - Integrate database changes seamlessly into your existing CI/CD workflows
- **Version Control Integration** - Manage schema changes alongside application code in your VCS
- **Automated Change Detection** - Intelligently detect and apply only necessary changes, ensuring idempotency
- **Progressive Deployment** - Roll out changes across environments (development → staging → production) with configurable automation and approval gates

### Enterprise-Grade Safety

- **SQL Review and Validation** - Automatic policy enforcement during pull requests
- **Rollback Capabilities** - Support for safe schema rollbacks when needed
- **Multi-Region Support** - Deploy to isolated regional databases with separate or unified Bytebase deployments
- **Batch Operations** - Apply changes across multiple databases consistently

## GitOps Workflow

### 1. Development Phase

Developers create SQL migration files in feature branches, following the same branch management strategy as application code (e.g., [GitHub Flow](https://docs.github.com/en/get-started/quickstart/github-flow), [GitLab Flow](https://docs.gitlab.com/ee/topics/gitlab_flow.html)).

### 2. Review Phase (Pull Request)

- Automated SQL review validates changes against configured policies
- Schema changes are reviewed alongside application code changes
- Compatibility checks ensure schema and code alignment

### 3. Release Creation and Deployment

After PR merge, releases can be created and deployed according to your workflow, consistent with application code deployment:

- GitOps integration can create versioned releases containing SQL migrations
- Releases are linked to commits for full traceability
- Deployment timing is configurable based on your pipeline strategy:
  - **Automatic**: Deploy immediately after merge (common for development/test environments)
  - **Time-based**: Schedule deployments for specific windows
  - **Manual approval**: Require explicit approval before deployment (common for production)
- Feature flags can decouple schema deployment from applications using new schema version

**Key Principle**: Bytebase automatically detects previously applied migrations and skips them, ensuring safe re-deployment and idempotent operations across all environments.
