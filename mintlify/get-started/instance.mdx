---
title: Connect Your Database
---

import PostgreSQLConfig from '/snippets/get-started/instance/postgresql.mdx';
import OracleConfig from '/snippets/get-started/instance/oracle.mdx';
import SnowflakeConfig from '/snippets/get-started/instance/snowflake.mdx';
import MongoDBConfig from '/snippets/get-started/instance/mongodb.mdx';
import ClickHouseConfig from '/snippets/get-started/instance/clickhouse.mdx';
import DatabricksConfig from '/snippets/get-started/instance/databricks.mdx';
import SpannerConfig from '/snippets/get-started/instance/spanner.mdx';

Learn how to connect Bytebase to your database instances, configure authentication, and set up advanced security options.

## Quick Start

Navigate to the configuration section for your cloud provider, or start with general configuration options that apply to all databases:

<Columns cols={4}>
  <Card title="General Setup" href="#general-configuration" icon="settings" />
  <Card title="AWS" href="#aws-configuration" icon="aws" />
  <Card title="Google Cloud" href="#gcp-configuration" icon="google" />
  <Card title="Azure" href="#azure-configuration" icon="microsoft" />
</Columns>

## General Configuration

### Basic Connection

Before configuring connection parameters, ensure network connectivity:

**Network Requirements:**
- Verify network routing between Bytebase and your database instance (e.g., VPN, private networks)
- Configure firewall rules to allow Bytebase to connect to your database port
- For cloud databases, add Bytebase to security groups or IP allowlists
- Bytebase Cloud users: [Whitelist required IPs](/get-started/cloud#prerequisites)

**Connection Parameters:**

1. **Host**: Database server address
   - Docker (standard): Use `host.docker.internal` for localhost databases
   - Docker (--network host): Use `127.0.0.1` for localhost databases

2. **Port**: Database port number (e.g., 5432 for PostgreSQL, 3306 for MySQL)

3. **Username & Password**: Database credentials with appropriate permissions

Additional parameters vary by database type - see [Database-Specific Guides](#database-specific-guides) for your database's requirements.

### Read-Only Connections

Configure separate read-only connections for enhanced security and performance. Read-only connections are used for:
- SQL Editor queries with [data source restrictions](/sql-editor/settings/data-source-restriction)
- [Export Center operations](/security/database-permission/export#request-from-export-center)

**Setup:**
1. Create a read-only database user or configure a read-replica
2. In Bytebase, click **+** next to **Connection Info**
3. Enter the read-only connection details
4. Save the configuration

### SSH Tunnel

<PricingPlanBlock feature_name="SSH_TUNNEL" />

Use SSH tunneling to connect through a bastion host or jump server when your database is behind a firewall, in a private network, or requires specific security policies for access. This is common for databases in different VPCs or restricted network segments.

**Setup:**
1. Enter your database connection details as usual
2. Enable **SSH Connection** and select **Tunnel + Private Key**
3. Configure SSH tunnel settings:
   - **SSH Host**: Bastion host or jump server address
   - **SSH Port**: SSH port (typically 22)
   - **SSH User**: Username for SSH authentication
   - **Private Key** or **Password**: SSH authentication credentials
4. Test the connection and save

### Connection Parameters

Customize connection behavior with database-specific parameters:

**Common Parameters:**

| Parameter | Description | Example | Databases |
|-----------|------------|---------|-----------|
| `sslmode` | SSL connection mode | `require` | PostgreSQL |
| `connect_timeout` | Connection timeout | `10` | PostgreSQL, MySQL |
| `readTimeout` | Read operation timeout | `30s` | MySQL, SQL Server |
| `max_connections` | Maximum connections | `100` | All |

**Database Documentation:**
- [PostgreSQL Parameters](https://www.postgresql.org/docs/current/libpq-connect.html)
- [MySQL Parameters](https://github.com/go-sql-driver/mysql#parameters)
- [SQL Server Parameters](https://pkg.go.dev/github.com/microsoft/go-mssqldb#section-readme)
- [Oracle Parameters](https://github.com/sijms/go-ora)

### Secret Manager

<PricingPlanBlock feature_name="EXTERNAL_SECRET_MANAGER" />

Integrate with external secret managers for centralized credential management. Use this for corporate compliance, automatic password rotation, or when you prefer not to store credentials directly in Bytebase.

**Supported Providers:**
- **HashiCorp Vault** - Configure below
- **[AWS Secrets Manager](#aws-secrets-manager)** - See AWS configuration section
- **[GCP Secret Manager](#gcp-secret-manager)** - See GCP configuration section
- **Custom API Endpoint** - Configure below

#### HashiCorp Vault

<Note>
Requires Vault KV v2 engine
</Note>

**Vault Setup:**
1. Create secret in Vault:
   - Engine: `secret`
   - Path: `bytebase`
   - Key: `DB_PASSWORD`
   - Value: Your password

**Bytebase Configuration:**
1. Enter Vault URL
2. Choose authentication method:
   - **[Token](https://developer.hashicorp.com/vault/docs/auth/token)**: Provide access token
   - **[AppRole](https://developer.hashicorp.com/vault/docs/auth/approle)**: Provide role ID and secret ID
3. Specify secret location (engine/path/key)

#### Custom API Endpoint

Integrate with custom secret managers using your API:

**Endpoint Format:** `{{http://example.com/secrets/mydbkey}}`

**Expected Response:**
```json
{
  "payload": {
    "data": "base64_encoded_password"
  }
}
```

## AWS Configuration

### RDS/Aurora with IAM Authentication

This guide demonstrates the most secure method for IAM authentication using EC2 instance profiles, which eliminates the need to manage access keys. 

For alternative authentication methods such as IAM users with access keys or cross-account access, refer to:
- [AWS RDS IAM Database Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html)
- [Connecting using IAM authentication from the command line](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.Connecting.html)
- [IAM authentication for cross-account access](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.CrossAccount.html)

#### Step 1: Configure RDS/Aurora Instance

Enable IAM authentication on your database instance:

1. **Enable IAM Database Authentication**
   - For existing instances: Modify instance → Database authentication → IAM database authentication
   - For new instances: Enable "Password and IAM database authentication" during creation
   - Reference: [Enabling IAM authentication](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.Enabling.html)

2. **Verify SSL/TLS** 
   - SSL is enabled by default on RDS (required for IAM auth)
   - No additional configuration needed

#### Step 2: Create IAM Role for EC2

1. **Create IAM Policy**
   - Go to IAM → Policies → Create policy
   - Choose JSON and paste:
   ```json
   {
     "Version": "2012-10-17",
     "Statement": [
       {
         "Effect": "Allow",
         "Action": "rds-db:connect",
         "Resource": "arn:aws:rds-db:REGION:ACCOUNT_ID:dbuser:DB_INSTANCE_ID/DB_USER"
       }
     ]
   }
   ```
   - Replace `REGION`, `ACCOUNT_ID`, `DB_INSTANCE_ID`, and `DB_USER` with your values
   - Or use wildcards (*) for broader access
   - Name the policy: `rds-iam-auth-policy`
   
   > **Production Best Practice:** Use specific ARNs instead of wildcards. See [AWS IAM Policy examples](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.IAMPolicy.html).

2. **Create IAM Role**
   - Go to IAM → Roles → Create role
   - Select trusted entity: `AWS service` → `EC2`
   - Attach the `rds-iam-auth-policy` created above
   - Name: `bytebase-rds-role`

#### Step 3: Setup EC2 Instance with IAM Role

1. **Attach IAM Role to EC2**
   - New instances: Select `bytebase-rds-role` during launch configuration
   - Existing instances: EC2 console → Actions → Security → Modify IAM role → Select `bytebase-rds-role`

2. **Deploy Bytebase**
   - Install Bytebase on your EC2 instance
   - No AWS credentials configuration needed - the IAM role provides automatic authentication

#### Step 4: Create Database User

Connect to your RDS instance and create an IAM-authenticated user:

**MySQL/Aurora MySQL:**
```sql
CREATE USER 'bytebase'@'%' IDENTIFIED WITH AWSAuthenticationPlugin AS 'RDS';
ALTER USER 'bytebase'@'%' REQUIRE SSL;
GRANT ALL PRIVILEGES ON *.* TO 'bytebase'@'%';
```

**PostgreSQL/Aurora PostgreSQL:**
```sql
CREATE USER bytebase;
GRANT rds_iam TO bytebase;
-- Grant appropriate database permissions as needed
```

Reference: [MySQL setup](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.DBAccounts.html#UsingWithRDS.IAMDBAuth.DBAccounts.MySQL) | [PostgreSQL setup](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.DBAccounts.html#UsingWithRDS.IAMDBAuth.DBAccounts.PostgreSQL)

#### Step 5: Connect from Bytebase

Configure the database connection in Bytebase:

1. Click **New Instance** in Bytebase
2. Enter connection details:
   - **Host:** Your RDS endpoint (found in RDS console)
   - **Port:** 3306 (MySQL) or 5432 (PostgreSQL)
   - **Username:** `bytebase`
   - **Authentication:** Select `AWS RDS IAM`

3. Test and save the connection

Bytebase automatically handles IAM token generation and refresh using the EC2 instance role.

<Tip>
IAM authentication tokens expire after 15 minutes, but Bytebase automatically refreshes them using the instance profile. Learn more about [IAM database authentication limitations](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html#UsingWithRDS.IAMDBAuth.Limitations).
</Tip>

### AWS Secrets Manager

#### Create an IAM user to access the Secrets Manager

<Tip>
It's recommended to create a dedicated IAM user for Bytebase to retrieve the secrets. You only need to do this once.
</Tip>

Visit [IAM](https://aws.amazon.com/iam/) to create a new IAM user. Name it `bytebase-external-secret`.

![](/content/docs/get-started/instance/aws-secrets-manager/iam-user-detail.webp)

Attach `SecretsManagerReadWrite` permission.

![](/content/docs/get-started/instance/aws-secrets-manager/iam-set-permission.webp)

After creating the IAM user, create an Access Key to be used by Bytebase later.

![](/content/docs/get-started/instance/aws-secrets-manager/iam-create-access-key.webp)

Select `Third-party service` as the use case.

![](/content/docs/get-started/instance/aws-secrets-manager/iam-access-key-use-case.webp)

Optionally set the description tag and in the `Retrieve access keys` screen, record `Access key` and `Secret access key`. They will be passed as environment variables when starting Bytebase.

![](/content/docs/get-started/instance/aws-secrets-manager/iam-access-key-info.webp)

#### Create secret

Visit [AWS Secrets Manager](https://aws.amazon.com/secrets-manager/) to store a new secret. Select `Other type of secret`, and add a key/value pair. The key is `DB_PASSWORD` and the value is your database user password.

![](/content/docs/get-started/instance/aws-secrets-manager/secret-type.webp)

Next to the `Configure secret`, use `bytebase` as the Secret name

![](/content/docs/get-started/instance/aws-secrets-manager/configure-secret.webp)

Skip rotation, review and create the secret.

#### Use secret in Bytebase

Restart Bytebase with the following environment variables:

```bash
docker run --init \
  -e AWS_REGION=us-east-1 \
  -e AWS_ACCESS_KEY_ID=xxx \
  -e AWS_SECRET_ACCESS_KEY=yyy \
  ...
```

Go to instance setting, specify `bytebase` as the Secret name and `DB_PASSWORD` as the Secret key. These two correspond to the value you created in the AWS Secrets Manager.

![](/content/docs/get-started/instance/aws-secrets-manager/auth.webp)

## GCP Configuration

### Cloud SQL with IAM Authentication

This guide demonstrates the most secure method for IAM authentication using GCE VM service accounts, which eliminates the need to manage service account keys.

For alternative authentication methods, refer to the official Google Cloud documentation:
- [Cloud SQL IAM database authentication overview](https://cloud.google.com/sql/docs/mysql/iam-authentication)
- [Using automatic IAM database authentication](https://cloud.google.com/sql/docs/mysql/iam-authentication#automatic)
- [Configuring instances for IAM database authentication](https://cloud.google.com/sql/docs/mysql/create-edit-iam-instances)
- [Managing users with IAM database authentication](https://cloud.google.com/sql/docs/mysql/iam-users)

#### Step 1: Create and Configure GCE VM with Service Account

1. **Create a Service Account**
   - Go to [IAM & Admin → Service Accounts](https://console.cloud.google.com/iam-admin/serviceaccounts)
   - Click **Create Service Account**
   - Name: `bytebase-cloudsql` 
   - Description: "Service account for Bytebase to connect to Cloud SQL"
   - Click **Create and Continue**

2. **Grant Required Permissions**
   - Add these roles to the service account:
     - `Cloud SQL Client` (for database connections)
     - `Cloud SQL Instance User` (for IAM authentication)
   - Click **Continue** and then **Done**
   - Note the service account email: `bytebase-cloudsql@PROJECT_ID.iam.gserviceaccount.com`

3. **Create GCE VM with Service Account**
   - Go to [Compute Engine → VM instances](https://console.cloud.google.com/compute/instances)
   - Click **Create Instance**
   - Under **Identity and API access**:
     - Service account: Select `bytebase-cloudsql@PROJECT_ID.iam.gserviceaccount.com`
     - Access scopes: Select "Allow full access to all Cloud APIs" or manually select Cloud SQL scopes
   - Configure other VM settings as needed
   - Click **Create**

   > **Security Best Practice:** The VM automatically receives credentials through the metadata service. No service account keys are needed, reducing security risks. Learn more: [Service account impersonation](https://cloud.google.com/iam/docs/service-account-impersonation)

#### Step 2: Configure Cloud SQL Instance

1. **Enable IAM Authentication**
   - Go to [Cloud SQL Instances](https://console.cloud.google.com/sql/instances)
   - Select your instance or create a new one
   - Click **Edit**
   - Under **Customize your instance** → **Flags**:
     - Add flag: `cloudsql_iam_authentication` = `on`
   - Click **Save**
   
   Reference: [Configuring instances for IAM authentication](https://cloud.google.com/sql/docs/mysql/create-edit-iam-instances)

2. **Verify SSL/TLS Configuration**
   - SSL is required for IAM authentication
   - Cloud SQL enables SSL by default - no additional configuration needed
   - Reference: [Configuring SSL/TLS](https://cloud.google.com/sql/docs/mysql/configure-ssl-instance)

#### Step 3: Create Database Users

Connect to your Cloud SQL instance using the root user or an admin account:

**Cloud SQL for MySQL:**
```sql
CREATE USER 'bytebase-cloudsql'@'%' IDENTIFIED WITH 'cloudsql_iam_user';
```

**Cloud SQL for PostgreSQL:**
```sql
CREATE USER "bytebase-cloudsql@PROJECT_ID.iam" WITH LOGIN;
GRANT cloudsqliamuser TO "bytebase-cloudsql@PROJECT_ID.iam";
```

Reference: [MySQL IAM users](https://cloud.google.com/sql/docs/mysql/iam-users) | [PostgreSQL IAM users](https://cloud.google.com/sql/docs/postgres/iam-users)

#### Step 4: Deploy Bytebase on GCE VM

Deploy Bytebase on your GCE VM instance. The VM's attached service account credentials are automatically available to Bytebase through the metadata service - no GOOGLE_APPLICATION_CREDENTIALS configuration needed.

#### Step 5: Connect from Bytebase

1. Access Bytebase at `http://VM_EXTERNAL_IP:5678`
2. Click **New Instance**
3. Configure the connection:
   - **Host:** Your Cloud SQL connection name (format: `PROJECT_ID:REGION:INSTANCE_ID`)
     - Find this in Cloud SQL console → Instance details → Connection name
   - **Port:** 3306 (MySQL) or 5432 (PostgreSQL)
   - **Username:** 
     - MySQL: `bytebase-cloudsql`
     - PostgreSQL: `bytebase-cloudsql@PROJECT_ID.iam`
   - **Authentication:** Select `Google Cloud SQL IAM`
4. Test and save the connection

<Tip>
The GCE VM approach eliminates service account key management - credentials are automatically handled through the metadata service. Learn more: [Application Default Credentials](https://cloud.google.com/docs/authentication/application-default-credentials) | [Troubleshooting IAM authentication](https://cloud.google.com/sql/docs/mysql/iam-authentication#troubleshooting)
</Tip>

### GCP Secret Manager

#### Create a service account to access the Secret Manager

<Tip>
It's recommended to create a dedicated service account for Bytebase to retrieve the secrets. You only need to do this once.
</Tip>

Visit [Service accounts](https://console.cloud.google.com/iam-admin/serviceaccounts) to create a new service account.

![](/content/docs/get-started/instance/gcp-secret-manager/create-service-account-name.webp)

Grant `Secret Manager Secret Accessor` permission to the service account.

![](/content/docs/get-started/instance/gcp-secret-manager/create-service-account-permission.webp)

After the service account is created, visit its `KEYS` page and add a new key.

![](/content/docs/get-started/instance/gcp-secret-manager/create-key-file.webp)

Choose `JSON` as the key type and create. Keep the downloaded private key file. This will be passed as environment variables when starting Bytebase.

![](/content/docs/get-started/instance/gcp-secret-manager/create-key-file2.webp)

#### Create secret

Visit [GCP Secret Manager](https://console.cloud.google.com/security/secret-manager/create) to create a new secret.

![](/content/docs/get-started/instance/gcp-secret-manager/create-secret.webp)

After creation, note the fully qualified secret name.

![](/content/docs/get-started/instance/gcp-secret-manager/secret-full-name.webp)

#### Use secret in Bytebase

Restart Bytebase by specifying `GOOGLE_APPLICATION_CREDENTIALS`=`private key file` as an environment variable. The private key file is the JSON file downloaded before for the service account.

<Tip>
If you run Bytebase in docker, you need to put the JSON file under the mounted directory. Otherwise, Bytebase won't be able to access the key file.
</Tip>

```bash
docker run --init \
  -e GOOGLE_APPLICATION_CREDENTIALS=/var/opt/bytebase/key.json \
  ...
```

Go to instance setting, specify the fully qualified name such as `projects/228712144016/secrets/DB_PASSWORD` as the Secret full name.

![](/content/docs/get-started/instance/gcp-secret-manager/auth.webp)

## Azure Configuration

### Azure SQL with Managed Identity Authentication

This guide demonstrates the most secure method for connecting to Azure SQL Database and Azure SQL Managed Instance using VM-attached managed identities, eliminating the need to manage credentials or connection strings.

For alternative authentication methods and detailed configuration options, refer to:
- [Azure SQL authentication methods overview](https://learn.microsoft.com/en-us/azure/azure-sql/database/authentication-aad-overview)
- [Managed identities for Azure resources](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/overview)
- [Configure Azure AD authentication for SQL Database](https://learn.microsoft.com/en-us/azure/azure-sql/database/authentication-aad-configure)
- [Connect to Azure SQL with managed identity](https://learn.microsoft.com/en-us/azure/azure-sql/database/authentication-azure-ad-user-assigned-managed-identity)

#### Step 1: Create Azure VM with System-Assigned Managed Identity

1. **Create VM with Managed Identity**
   - Go to [Azure Portal → Virtual Machines](https://portal.azure.com/#blade/HubsExtension/BrowseResource/resourceType/Microsoft.Compute%2FVirtualMachines)
   - Click **Create** → **Azure virtual machine**
   - Configure VM settings as needed
   - Under **Management** tab:
     - Enable **System assigned managed identity**: Set to **On**
   - Complete VM creation
   
   > **Security Best Practice:** System-assigned managed identities are automatically managed by Azure and tied to the VM lifecycle. This eliminates credential management and reduces security risks. Learn more: [Managed identity best practices](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/managed-identity-best-practice-recommendations)

2. **Deploy Bytebase on the VM**
   
   Deploy Bytebase on your Azure VM. The VM's managed identity is automatically available - no credential configuration needed.

#### Step 2: Configure Azure SQL Database

1. **Enable Microsoft Entra Authentication**
   - Navigate to your Azure SQL Server in [Azure Portal](https://portal.azure.com)
   - Go to **Settings** → **Microsoft Entra ID**
   - Click **Set admin** and select an Entra admin account
   - Click **Save** to enable Entra authentication
   
   Reference: [Configure Entra authentication for Azure SQL](https://learn.microsoft.com/en-us/azure/azure-sql/database/authentication-aad-configure)

2. **Grant Database Access to Managed Identity**
   - Note your VM's managed identity name (same as VM name)
   - Connect to Azure SQL using the Entra admin account
   - Run the following for each database:

   ```sql
   -- Create user for the VM's managed identity
   CREATE USER [your-vm-name] FROM EXTERNAL PROVIDER;
   
   -- Grant appropriate permissions (adjust as needed)
   ALTER ROLE db_datareader ADD MEMBER [your-vm-name];
   ALTER ROLE db_datawriter ADD MEMBER [your-vm-name];
   ALTER ROLE db_ddladmin ADD MEMBER [your-vm-name];
   
   -- For full database management in Bytebase:
   ALTER ROLE db_owner ADD MEMBER [your-vm-name];
   ```
   
   > **Production Best Practice:** Follow the principle of least privilege. Grant only the minimum permissions required for your use case. See [Azure SQL Database permissions](https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage).

#### Step 3: Connect from Bytebase

1. Access Bytebase on your VM (typically `http://localhost:5678`)
2. Click **New Instance**
3. Configure the connection:
   - **Host:** Your Azure SQL server name (e.g., `yourserver.database.windows.net`)
   - **Port:** 1433
   - **Database:** Target database name
   - **Authentication:** Select `Azure Default Credential`
4. Test and save the connection

Bytebase automatically uses the VM's managed identity through Azure's Instance Metadata Service (IMDS) for authentication.

<Tip>
**Advantages of this approach:**
- No passwords or connection strings to manage
- Automatic credential rotation handled by Azure
- Enhanced security through Azure RBAC
- Simplified compliance and auditing

For troubleshooting, see [Troubleshoot managed identity authentication](https://learn.microsoft.com/en-us/azure/azure-sql/database/authentication-azure-ad-user-assigned-managed-identity#troubleshooting).
</Tip>

#### Alternative: User-Assigned Managed Identity

For more granular control or cross-resource scenarios:

1. **Create User-Assigned Managed Identity**
   - Go to [Managed Identities](https://portal.azure.com/#blade/HubsExtension/BrowseResource/resourceType/Microsoft.ManagedIdentity%2FuserAssignedIdentities)
   - Create a new identity with a descriptive name
   - Assign it to your VM under **Settings** → **Identity** → **User assigned**

2. **Configure Database Access**
   ```sql
   CREATE USER [managed-identity-name] FROM EXTERNAL PROVIDER;
   ALTER ROLE db_owner ADD MEMBER [managed-identity-name];
   ```

3. **Set Environment Variable** (if using multiple identities)
   ```bash
   export AZURE_CLIENT_ID=<managed-identity-client-id>
   ```

Reference: [User-assigned managed identities](https://learn.microsoft.com/en-us/entra/identity/managed-identities-azure-resources/how-manage-user-assigned-managed-identities)

## Database-Specific Guides

Configure connection settings for specific database types:

<Tabs>
  <Tab title="PostgreSQL">
    <PostgreSQLConfig />
  </Tab>
  <Tab title="Oracle">
    <OracleConfig />
  </Tab>
  <Tab title="MongoDB">
    <MongoDBConfig />
  </Tab>
  <Tab title="Snowflake">
    <SnowflakeConfig />
  </Tab>
  <Tab title="ClickHouse">
    <ClickHouseConfig />
  </Tab>
  <Tab title="Databricks">
    <DatabricksConfig />
  </Tab>
  <Tab title="Spanner">
    <SpannerConfig />
  </Tab>
</Tabs>

