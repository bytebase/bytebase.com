---
title: 'Data Masking with GitHub Actions Part 1 - Semantic Type and Global Masking Rule'
author: Ningjing
updated_at: 2025/01/17 18:00
tags: Tutorial
integrations: API, GitHub
level: Advanced
estimated_time: '30 mins'
description: 'Learn how to automate semantic type and global masking rule using GitHub Actions and Bytebase API'
---

<IncludeBlock url="/docs/share/tutorials/api-preface"></IncludeBlock>

Bytebase provides database [dynamic data masking](/docs/security/data-masking/overview/) in the **Enterprise Plan**, which can mask sensitive data in the SQL Editor query result based on the context on the fly. It helps organizations to protect sensitive data from being exposed to unauthorized users.

By using GitHub Actions with Bytebase API, you can implement policy-as-code to apply database masking policies via the GitOps workflow. This tutorial will guide you through the process.

---

This is Part 1 of our tutorial series on implementing automated database masking using GitHub Actions:

- Part 1: [Semantic Type and Global Masking Rule](/docs/tutorials/github-action-data-masking-part1)
- Part 2: [Column Masking and Masking Exemption](/docs/tutorials/github-action-data-masking-part2)
- Part 3: [Data Classification](/docs/tutorials/github-action-data-masking-part3)
- Part 4: Data Export with Masking (TBD)

## Overview

In this tutorial, you'll learn how to automate database masking policies using GitHub Actions and the Bytebase API. This integration allows you to:

- Manage data masking rules as code
- Automatically apply masking policies when PRs are merged

Here is [a merged pull request](https://github.com/bytebase/database-security-github-actions-example/pull/81) as an example, for this tutorial, only "Semantic Type and Global Masking Rule" is covered.

<HintBlock type="info">

The complete code for this tutorial is available at: [database-security-github-actions-example](https://github.com/bytebase/database-security-github-actions-example)

</HintBlock>

## Prerequisites

Before you begin, make sure you have:

- [Docker](https://www.docker.com/) installed
- A [GitHub](https://github.com/) account
- An [ngrok](http://ngrok.com/) account
- Bytebase Enterprise Plan subscription (you can request a free trial)

## Setup Instructions

### Step 1 - Start Bytebase in Docker and set the External URL generated by ngrok

<IncludeBlock url="/docs/get-started/install/vcs-with-ngrok"></IncludeBlock>

### Step 2 - Create Service Account

<IncludeBlock url="/docs/share/tutorials/create-service-account"></IncludeBlock>

### Step 3 - Prepare Test Data

1. Bytebase by default provides a project `Sample Project` with two database `hr_test` and `hr_prod`.
1. Click **IAM & Admin > Users & Groups** on the left sidebar. Add users: `dev@example.com`, `dev2@example.com` and `dev3@example.com` with no roles.
1. Add a group `contractor@example.com` with `dev3@example.com` as a member.
1. Go to project `Sample Project`, click **Manage > Members** on the left sidebar.
1. Click **Grant Access** and select users `dev@example.com` and `dev2@example.com` with `Developer` role and group `contractor@example.com` with `Querier` role.

### Step 4 - Configure GitHub Actions

1. Fork [Database Security GitHub Actions Example](https://github.com/bytebase/database-security-github-actions-example).

1. Click **Settings** and then click **Secrets and variables > Actions**. Add the following secrets:

   - `BYTEBASE_URL`: ngrok external URL
   - `BYTEBASE_SERVICE_KEY`: `api-example@service.bytebase.com`
   - `BYTEBASE_SERVICE_SECRET`: service key copied in the previous step

### Step 5 - Understanding the GitHub Workflow

Let's dig into the GitHub Actions workflow [code](https://github.com/bytebase/database-security-github-actions-example/blob/main/.github/workflows/1-bb-masking-semantic-type-global.yml):

1. **Trigger**: Workflow runs when PRs are merged to `main`.

1. **Authentication**: The step `Login Bytebase` will log in Bytebase using the official [bytebase-login](https://github.com/marketplace/actions/bytebase-login) action. The variables you configured in the GitHub **Secrets and variables** are mapped to the variables in the action.

1. **File Detection**: The step `Get changed files` will monitor the changed files in the pull request. For this workflow, we only care about semantic type and global masking rule. So `masking/semantic-type.json` and `masking/global-masking-rule.json` are filtered out.

1. **PR Feedback**: The step `Comment on PR` will comment on the merged pull to notify the result.

## Semantic Type

Masking algorithm is associated with [Semantic Type](/docs/security/data-masking/semantic-types/). You define semantic types and apply them to global masking rule or table columns. For example, you may define a semantic type `birth_date` with a masking algorithm to mask month and day.

### In Bytebase Console

Go to **Data Access > Semantic Types** and click **Add**. You can create a new semantic type with a name and description, and customize the masking algorithm.

![bb-add-semantic-type](/content/docs/tutorials/github-action-data-masking-part1/bb-add-semantic-type.webp)

![bb-add-algorithm](/content/docs/tutorials/github-action-data-masking-part1/bb-add-algorithm.webp)

### In GitHub Workflow

Find the step `Apply semantic type`, which will apply the semantic type to the database via API. All the masking algorithms should be defined in one file in the root directory as `masking/semantic-type.json`.

```bash
response=$(curl -s -w "\n%{http_code}" --request PATCH "${BYTEBASE_API_URL}/settings/bb.workspace.semantic-types?allow_missing=true" \
   --header "Authorization: Bearer ${BYTEBASE_TOKEN}" \
   --header "Content-Type: application/json" \
   --data @"$CHANGED_FILE")
```

By changing file `masking/semantic-type.json`, creating a PR and merging, the semantic types will be applied. Go to Bytebase console, click **Data Access > Semantic Types**, you can see the applied semantic types.

## Global Masking Rule

[Global Masking Rule](/docs/security/data-masking/global-masking-rule/) is configured by the admin.

### In Bytebase Console

Go to **Data Access > Global Masking** and click **Add**. You can create a new global masking rule mapping condition to a semantic type.

![bb-global-masking](/content/docs/tutorials/github-action-data-masking-part1/bb-global-masking.webp)

### In GitHub Workflow

Find the step `Apply global masking rule`, which will apply the global masking rule to the database via API. All the global masking rules should be defined in one file in the root directory as `masking/global-masking-rule.json`. The code it calls Bytebase API is as follows:

```bash
response=$(curl -s -w "\n%{http_code}" --request PATCH "${BYTEBASE_API_URL}/policies/masking_rule?allow_missing=true&update_mask=payload" \
   --header "Authorization: Bearer ${BYTEBASE_TOKEN}" \
   --header "Content-Type: application/json" \
   --data @"$CHANGED_FILE")
```

By changing file `masking/global-masking-rule.json`, creating a PR and merge, you can apply the global masking rules.

<DocLinkBlock url="/docs/tutorials/github-action-data-masking-part2" title="Next Step: Column Masking and Masking Exemption"></DocLinkBlock>
